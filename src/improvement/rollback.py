"""Rollback manager - Git-based versioning for improvements.

This module handles:
- Creating snapshots before improvements
- Committing successful improvements
- Rolling back failed improvements
- Maintaining improvement history
"""
import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

from .generator import Improvement

logger = logging.getLogger(__name__)


@dataclass
class Snapshot:
    """A snapshot of the codebase before an improvement."""

    id: str
    commit_hash: str
    description: str
    timestamp: datetime


class RollbackManager:
    """Manages Git-based versioning for self-improvements."""

    def __init__(self, project_root: Path):
        """Initialize the rollback manager.

        Args:
            project_root: Root directory of the project (must be a git repo)
        """
        self.project_root = project_root
        self.snapshots: list[Snapshot] = []

    async def _run_git(self, *args) -> tuple[bool, str]:
        """Run a git command.

        Returns:
            Tuple of (success, output)
        """
        try:
            process = await asyncio.create_subprocess_exec(
                "git", *args,
                cwd=str(self.project_root),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                return False, stderr.decode()
            return True, stdout.decode().strip()

        except Exception as e:
            return False, str(e)

    async def is_git_repo(self) -> bool:
        """Check if project root is a git repository."""
        success, _ = await self._run_git("rev-parse", "--git-dir")
        return success

    async def has_uncommitted_changes(self) -> bool:
        """Check if there are uncommitted changes."""
        success, output = await self._run_git("status", "--porcelain")
        return success and bool(output.strip())

    async def get_current_commit(self) -> str | None:
        """Get the current commit hash."""
        success, output = await self._run_git("rev-parse", "HEAD")
        return output if success else None

    async def create_snapshot(self, description: str) -> str:
        """Create a snapshot of the current state.

        Args:
            description: Description of why snapshot is being created

        Returns:
            Snapshot ID
        """
        # Make sure we're in a git repo
        if not await self.is_git_repo():
            logger.error("Not a git repository")
            raise RuntimeError("Not a git repository")

        # Stash any uncommitted changes
        if await self.has_uncommitted_changes():
            await self._run_git("stash", "push", "-m", f"Auto-stash before: {description}")

        # Get current commit
        commit_hash = await self.get_current_commit()
        if not commit_hash:
            raise RuntimeError("Failed to get current commit")

        # Create snapshot
        snapshot_id = f"snap-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        snapshot = Snapshot(
            id=snapshot_id,
            commit_hash=commit_hash,
            description=description,
            timestamp=datetime.now(),
        )
        self.snapshots.append(snapshot)

        logger.info(f"Created snapshot {snapshot_id} at {commit_hash[:8]}")
        return snapshot_id

    async def commit_improvement(self, improvement: Improvement) -> str | None:
        """Commit an improvement to git.

        Args:
            improvement: The improvement that was applied

        Returns:
            Commit hash if successful
        """
        # Stage changed files
        for change in improvement.changes:
            rel_path = change.file_path.relative_to(self.project_root)
            await self._run_git("add", str(rel_path))

        # Build commit message
        commit_message = f"""AUTO-IMPROVEMENT: {improvement.title}

{improvement.description}

Improvement-ID: {improvement.id}
Changes: {len(improvement.changes)} files modified
Auto-generated by TWIZZY self-improvement system

Co-Authored-By: TWIZZY <twizzy@localhost>
"""

        # Commit
        success, output = await self._run_git(
            "commit", "-m", commit_message
        )

        if not success:
            logger.error(f"Failed to commit improvement: {output}")
            return None

        # Get new commit hash
        commit_hash = await self.get_current_commit()
        logger.info(f"Committed improvement {improvement.id} as {commit_hash[:8]}")

        return commit_hash

    async def rollback_to(self, snapshot_id: str) -> bool:
        """Rollback to a previous snapshot.

        Args:
            snapshot_id: ID of the snapshot to rollback to

        Returns:
            True if successful
        """
        # Find snapshot
        snapshot = next(
            (s for s in self.snapshots if s.id == snapshot_id),
            None
        )
        if not snapshot:
            logger.error(f"Snapshot not found: {snapshot_id}")
            return False

        # Reset to snapshot commit
        success, output = await self._run_git(
            "reset", "--hard", snapshot.commit_hash
        )

        if not success:
            logger.error(f"Failed to rollback: {output}")
            return False

        logger.info(f"Rolled back to snapshot {snapshot_id} ({snapshot.commit_hash[:8]})")
        return True

    async def rollback_last_improvement(self) -> bool:
        """Rollback the last improvement.

        Returns:
            True if successful
        """
        # Reset to previous commit
        success, output = await self._run_git("reset", "--hard", "HEAD~1")

        if not success:
            logger.error(f"Failed to rollback: {output}")
            return False

        logger.info("Rolled back last improvement")
        return True

    async def get_improvement_history(self, limit: int = 20) -> list[dict[str, Any]]:
        """Get history of auto-improvements from git log.

        Args:
            limit: Maximum number of improvements to return

        Returns:
            List of improvement records
        """
        success, output = await self._run_git(
            "log",
            "--oneline",
            "--grep=AUTO-IMPROVEMENT",
            f"-{limit}",
            "--pretty=format:%H|%s|%ai"
        )

        if not success or not output:
            return []

        history = []
        for line in output.split("\n"):
            if not line:
                continue
            parts = line.split("|")
            if len(parts) >= 3:
                history.append({
                    "commit": parts[0],
                    "title": parts[1].replace("AUTO-IMPROVEMENT: ", ""),
                    "timestamp": parts[2],
                })

        return history

    async def get_improvement_details(self, commit_hash: str) -> dict[str, Any] | None:
        """Get details of a specific improvement.

        Args:
            commit_hash: The commit hash of the improvement

        Returns:
            Improvement details or None
        """
        # Get commit message
        success, message = await self._run_git("log", "-1", "--pretty=format:%B", commit_hash)
        if not success:
            return None

        # Get changed files
        success, files = await self._run_git("diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash)
        if not success:
            return None

        # Parse improvement ID from message
        import re
        id_match = re.search(r"Improvement-ID: (\S+)", message)

        return {
            "commit": commit_hash,
            "message": message,
            "improvement_id": id_match.group(1) if id_match else None,
            "files_changed": files.strip().split("\n") if files else [],
        }
